//! Story time
//!
//! Read aloud something generated by chatgpt
#![warn(
    rust_2018_idioms,
    unused,
    rust_2021_compatibility,
    nonstandard_style,
    future_incompatible,
    missing_copy_implementations,
    missing_debug_implementations,
    missing_docs,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo,
    clippy::unwrap_used,
    clippy::missing_assert_message,
    clippy::todo,
    clippy::allow_attributes_without_reason,
    clippy::panic,
    clippy::panicking_unwrap,
    clippy::panic_in_result_fn
)]

mod command;
mod io;
mod logging;
mod remote;

use clap::{Parser, Subcommand};

use miette::Result;

use command::read_aloud;
use std::path::PathBuf;

use remote::chatgpt;
use remote::elevenlabs;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
    /// Log level
    ///
    /// Can be trace, debug, info, warn, error, or off. You can also put a module name after a comma
    /// to set a specific log level for that module "error,hello=warn" turn on global error logging
    /// and also warn for hello
    #[arg(short, long, env, default_value = "info")]
    rust_log: String,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Read a prompt from ChatGPT aloud
    ReadAloud {
        /// Key for ChatGPT
        #[arg(short, long, env)]
        chatgpt_key: String,
        /// Key for ElevenLabs
        #[arg(short, long, env)]
        elevenlabs_key: String,
        /// Prompt to give to ChatGPT
        #[arg(short, long, env)]
        chatgpt_prompt: String,
        /// A style to read in
        #[arg(short, long, env, default_value = "You are reading aloud")]
        chatgpt_direction: String,

        /// ID of the voice to use
        #[arg(short, long, env, default_value = "MF3mGyEYCl7XYWbV9V6O")]
        elevenlabs_voice: String,

        /// Save to a file rather than reading aloud
        #[arg(short, long, env)]
        output: Option<PathBuf>,
    },
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Cli::parse();
    logging::setup(&args.rust_log)?;

    match args.command {
        Commands::ReadAloud {
            chatgpt_key,
            elevenlabs_key,
            chatgpt_prompt,
            chatgpt_direction,
            elevenlabs_voice,
            output,
        } => {
            let chatgpt_client = chatgpt::ChatGPT::try_new(chatgpt_key)?;
            let elevenlabs_client = elevenlabs::Reqwest::try_new(elevenlabs_key)?;

            read_aloud::Command::new(chatgpt_client, elevenlabs_client)
                .run(chatgpt_direction, chatgpt_prompt, elevenlabs_voice, output)
                .await?;
        }
    }
    Ok(())
}
